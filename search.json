[{"title":"Hello World","url":"/2020/08/28/Test/","content":"<blockquote>\n<p>这是一篇<strong>测试文档</strong>，秃头的一晚上（好吧它并不难）。</p>\n</blockquote>\n"},{"title":"关于NexT主题添加搜索功能的坑","url":"/2020/08/29/%E5%85%B3%E4%BA%8ENexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E7%9A%84%E5%9D%91/","content":"<blockquote>\n<p>多方教程在讲到添加搜索功能时候会教你修改主站配置文件时添加以下代码<a id=\"more\"></a></p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">search:</span><br><span class=\"line\">    path: search.xml</span><br><span class=\"line\">    field: post</span><br><span class=\"line\">    format: html</span><br><span class=\"line\">    limit: 10000</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>实测需要将<strong>path: search.xml</strong>改为<strong>path: search.json</strong>才能正常显示搜索框<!--more--></p>\n</blockquote>\n","tags":["-Next主题"]},{"title":"你好，访问者","url":"/2020/08/28/%E4%BD%A0%E5%A5%BD/","content":"<blockquote>\n<p>经过一番折腾，这个博客<strong>终于</strong>，弄完了，欢迎来添加友链。<a id=\"more\"></a><br>将会不定时更新。<br>QQ联系：<strong>1364768411</strong><!--more--></p>\n</blockquote>\n"},{"title":"【模板】单源最短路径（标准版）","url":"/2020/09/06/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(%E6%A0%87%E5%87%86%E7%89%88)/","content":"<p> 题目来源：洛谷P4479：<a href=\"https://www.luogu.com.cn/problem/P4779\">【模板】单源最短路径（标准版）</a><a id=\"more\"></a></p>\n<h2 id=\"题目背景\"><a href=\"#题目背景\" class=\"headerlink\" title=\"题目背景\"></a>题目背景</h2><p>  2018 年 7 月 19 日，某位同学在 NOI Day 1 T1 归程 一题里非常熟练地使用了一个广为人知的算法求最短路。<br>  然后呢？<br>  100 → 60;<br>  Ag→Cu；<br>  最终，他因此没能与理想的大学达成契约。<br>  小 F 衷心祝愿大家不再重蹈覆辙。  </p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>  给定一个 n 个点，m 条有向边的带非负权图，请你计算从 s 出发，到每个点的距离。<br>  数据保证你能从 s 出发到任意点。  </p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>  第一行为三个正整数n,m,s。第二行起m行，每行三个非负整数 u_i, v_i, w_i ，表示从 u_i到 v_i 有一条权值为 w_i的有向边。  </p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>  输出一行 n 个空格分隔的非负整数，表示 s 到每个点的距离。 </p>\n<h2 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h2><h2 id=\"输入-1\"><a href=\"#输入-1\" class=\"headerlink\" title=\"输入 #1\"></a>输入 #1</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">4 6 1</span><br><span class=\"line\">1 2 2</span><br><span class=\"line\">2 3 2</span><br><span class=\"line\">2 4 1</span><br><span class=\"line\">1 3 5</span><br><span class=\"line\">3 4 3</span><br><span class=\"line\">1 4 4</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"输出-1\"><a href=\"#输出-1\" class=\"headerlink\" title=\"输出 #1\"></a>输出 #1</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">0 2 4 3</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"说明-提示\"><a href=\"#说明-提示\" class=\"headerlink\" title=\"说明/提示\"></a>说明/提示</h2><p>$\\begin{array}{l}<br>1 \\leq n \\leq 10^{5} \\text { ; } \\<br>1 \\leq m \\leq 2 \\times 10^{5} \\text { ; } \\<br>s=1 \\text { ; } \\<br>1 \\leq u_{i}, v_{i} \\leq n \\text { ; } \\<br>0 \\leq w_{i} \\leq 10^{9} \\<br>0 \\leq \\sum w_{i} \\leq 10^{9} \\text { . }<br>\\end{array}$</p>\n<h2 id=\"关于解法\"><a href=\"#关于解法\" class=\"headerlink\" title=\"关于解法\"></a>关于解法</h2><blockquote>\n<h3 id=\"具体思路：前向星存图、堆优化的djk\"><a href=\"#具体思路：前向星存图、堆优化的djk\" class=\"headerlink\" title=\"具体思路：前向星存图、堆优化的djk\"></a>具体思路：前向星存图、堆优化的djk</h3><p>代码如下，自带详细注释。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//by RichardSun</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MaxN = <span class=\"number\">100010</span>, MaxM = <span class=\"number\">500010</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> to, val, next;</span><br><span class=\"line\">&#125;Edge[MaxM]; <span class=\"comment\">// 链式前向星 </span></span><br><span class=\"line\"><span class=\"keyword\">int</span> head[MaxN], dis[MaxN], num=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[MaxN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m, s;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">add_Edge</span><span class=\"params\">( <span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> d )</span> <span class=\"comment\">//加边操作 </span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ++num;</span><br><span class=\"line\">    Edge[num].val = d; <span class=\"comment\">//赋权 </span></span><br><span class=\"line\">    Edge[num].to = v; <span class=\"comment\">// 这条边终点 </span></span><br><span class=\"line\">    Edge[num].next = head[u]; <span class=\"comment\">//下一条边的下标 </span></span><br><span class=\"line\">    head[u] = num;<span class=\"comment\">//设置第一条边为当前边 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val; <span class=\"comment\">//距离 </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> pos; <span class=\"comment\">//点的位置</span></span><br><span class=\"line\">    node()&#123;&#125;</span><br><span class=\"line\">    node(<span class=\"keyword\">int</span> p , <span class=\"keyword\">int</span> v)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pos=p;</span><br><span class=\"line\">        val=v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> node &amp;a)<span class=\"keyword\">const</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> val &gt; a.val;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">//重载&quot;&lt;&quot; </span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; ;<span class=\"comment\">//结构体 结点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> start)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">priority_queue</span>&lt;node&gt;que;</span><br><span class=\"line\"><span class=\"comment\">/*for(int i = 1 ; i&lt;=n ; ++i)</span></span><br><span class=\"line\"><span class=\"comment\">    &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        dis[i]=0x3f;</span></span><br><span class=\"line\"><span class=\"comment\">        vis[i]=false;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;*/</span></span><br><span class=\"line\">    dis[start]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    que.push( node(start,<span class=\"number\">0</span>) );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        node temp=que.top(); <span class=\"comment\">//优先队列首元素就是dist数组最小值</span></span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mini=temp.pos; <span class=\"comment\">//最小值为首元素节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[mini])</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            vis[mini]=<span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">//判断最小值是否被找过，如果找过则跳过继续。 </span></span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=head[mini] ; i ; i=Edge[i].next)<span class=\"comment\">//首尾相连更新距离 </span></span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> to=Edge[i].to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis[to]&gt;dis[mini]+Edge[i].val)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dis[to]=dis[mini]+Edge[i].val;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!vis[to])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    que.push(node(to,dis[to]));</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"built_in\">scanf</span>( <span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s );</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i)dis[i] = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">register</span> <span class=\"keyword\">int</span> u, v, d;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>( <span class=\"string\">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;d );</span><br><span class=\"line\">        add_Edge( u, v, d );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dijkstra(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++ )</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>( <span class=\"string\">&quot;%d &quot;</span>, dis[i] );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首次发表于 2019-09-16 12:46:56 <a href=\"https://sunrichard993.blog.luogu.org/solution-p4779\">洛谷题解</a><br>by RichardSun<br>  <!--more--></p>\n"}]